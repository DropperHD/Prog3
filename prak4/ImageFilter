/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package imagefilter;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.DoubleUnaryOperator;

public class ImageFilter {

  private static double[][] filterImageParallel(
      double[][] from, 
      int width, int height, 
      DoubleUnaryOperator operator,
      int threads) throws InterruptedException{

    ExecutorService tp = Executors.newFixedThreadPool(threads);

    int colsPerThread = width / threads;
    int remainder = width % threads;
    int colsProcessed = 0;


    /* Variante mit CountDownLatch */
    // CountDownLatch countDownLatch = new CountDownLatch(threads);

    double[][] to = new double[width][height];

    for (int i = 0; i < threads; i++){

      final int cols = colsPerThread + (i < remainder ? 1 : 0);
      final int startCol = colsProcessed;


      tp.execute(
          () ->{
            filterImage(
                from, to, 
                startCol, cols,
                height,
                operator);

            /* Variante mit CountDownLatch */
            // countDownLatch.countDown();
          });

      colsProcessed += cols;

    }

    /* Variante mit CountDownLatch */
    // countDownLatch.await();

    tp.shutdown();

    try {
      while (!tp.awaitTermination(1, TimeUnit.SECONDS))
        System.out.println("Still waiting");
    } catch (InterruptedException e){
      e.printStackTrace();
      Thread.currentThread().interrupt();
    }
    return to;

}

  private static void filterImage(
      double[][] from, double[][] to, 
      int startCol, int cols,
      int height, 
      DoubleUnaryOperator operator){

    for (int x = startCol; x < startCol+cols; x++){
      for (int y = 0; y < height; y++){
        to[x][y] = operator.applyAsDouble(from[x][y]);
      }
    }

  }

  public static double[][] filterImage(
      double[][] source,
      int width, int height, 
      DoubleUnaryOperator operator){

    double[][] result = new double[width][height];

    for (int x = 0; x < width; x++){
      for (int y = 0; y < height; y++){
        result[x][y] = operator.applyAsDouble(source[x][y]);
      }
    }

    return result;

  }

  public static void main(String[] args) throws InterruptedException {

    if (args.length == 0){
      double[][] originalImage = ImageUtils.loadImage();

      int width = originalImage.length;
      int height = originalImage[0].length;

      double[][] resultImage = filterImageParallel(
          originalImage, width, height,
          v -> 1-v,
          4);

      ImageUtils.saveImage(resultImage);
    } else {
      ImageFilterPipeline pipeline = new ImageFilterPipeline(args, "filtered-");
      pipeline.start();
    }
  }
}
